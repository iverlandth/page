<div id="readme" class="blob instapaper_body">
<article itemprop="mainContentOfPage"><h2>
  <a name="control-de-flujo" class="anchor" href="#control-de-flujo"><span class="mini-icon mini-icon-link"></span></a>Control
  de Flujo</h2>

<p>Ahhhh, control de flujo. Acá es donde todo empieza a encajar. A pesar que este
  capítulo es más corto y facil que el capítulo de
  <%= link_to "métodos", :controller => :ruby, :action => :metodos %>,
  te abrirá un mundo nuevo de posibilidades para programar.</p>

<p>Luego de este capítulo, seremos capaces de escribir programas realmente interactivos; previamente
  hemos creado programas que <em>dicen</em> distintas cosas dependiente de lo que ingreses en
  tu teclado, pero luego de este capítulo estos también <em>harán</em> distintas cosas. Pero
  antes que podamos hacer eso, necesitamos ser capaces de comparar objectos en nuestros
  programas. Necesitamos...</p>

<h2>
  <a name="m%C3%A9todos-de-comparaci%C3%B3n" class="anchor" href="#m%C3%A9todos-de-comparaci%C3%B3n"><span class="mini-icon mini-icon-link"></span></a>Métodos
  de comparación</h2>

<p>Avancemos rápidamente por esta sección para que podamos ir a la siguiente,
  <strong>Ramificaciones</strong>, donde todas las cosas geniales ocurren. Entonces, para ver
  si un objeto es mayor o menor que otro, usaremos los métodos <code>&gt;</code> y <code>&lt;</code>, así:</p>

<p><em>Código:</em></p>

<pre><code>puts 1 &gt; 2
  puts 1 &lt; 2
</code></pre>

<p><em>Resultado:</em></p>

<pre><code>false
  true
</code></pre>

<p>Sin problemas. De igual manera, podemos identificar si un objeto es mayor-o-igual-que otro o
  menor-o-igual-que con los métodos <code>&gt;=</code> y <code>&lt;=</code></p>

<p><em>Código:</em></p>

<pre><code>puts 5 &gt;= 5
  puts 5 &lt;= 4
</code></pre>

<p><em>Resultado:</em></p>

<pre><code>true
  false
</code></pre>

<p>Finalmente, podemos ver si dos objetos son iguales o no utilizando <code>==</code> (que
  significa "¿son éstos iguales?") y <code>!=</code> (que significa "¿son éstos diferentes?").</p>

<p>Es importante no confundir <code>=</code> con <code>==</code>. <code>=</code> se utiliza para decirle a una variable
  a que objeto apuntar (asignación) y <code>==</code> se utiliza para responder la pregunta:
  "¿Son estos dos objetos iguales?".</p>

<p><em>Código:</em></p>

<pre><code>puts 1 == 1
  puts 2 != 1
</code></pre>

<p><em>Resultado:</em></p>

<pre><code>true
  true
</code></pre>

<p>Por supuesto, podemos comparar textos también. Cuando los textos se comparan,
  comparan su <em>ordenamiento lexicográfico</em>, que básicamente significa su orden en
  un diccionario. <code>gato</code> aparece antes que <code>perro</code> en el diccionario, así que:</p>

<p><em>Código:</em></p>

<pre><code>puts 'gato' &lt; 'perro'
</code></pre>

<p><em>Resultado:</em></p>

<pre><code>true
</code></pre>

<p>Sin embargo, hay algo que tener en cuenta: la manera en que las computadoras
  normalmente asumen que las letras mayúsculas vienen antes que las letras
  minúsculas (Así es como almacenan los caracteres en las fuentes, por ejemplo:
  los caracteres en mayúscula primero y en minúscula después).</p>

<p>Esto significa que pensará que <code>'Zoológico'</code> aparece antes que <code>'ave'</code>, así que si
  quieres encontrar que palabra aparecería antes en un diccionario real, asegúrate de
  utilizar <code>downcase</code> (o <code>upcase</code> o <code>capitalize</code>) en ambas palabras antes de tratar
  de compararlas.</p>

<p>Un último comentario antes de revisar <strong>Ramificaciones</strong>: Los métodos de comparación
  no nos están dando los textos <code>'true'</code> o <code>'false'</code> ("verdadero" y "falso" en español);
  nos están dando los objetos especiales <code>true</code> y <code>false</code>. (Por supuesto, <code>true.to_s</code>
  nos devuelve <code>'true'</code>, que es por lo que <code>puts</code> imprimió <code>'true'</code>.)</p>

<p><code>true</code> y <code>false</code> se utilizan todo el tiempo en...</p>

<h2>
  <a name="ramificaciones" class="anchor" href="#ramificaciones"><span class="mini-icon mini-icon-link"></span></a>Ramificaciones
</h2>

<p>Las Ramificaciones son un concepto simple, pero poderoso. De hecho, es tan simple que no necesito explicarlo,
  solo te lo mostraré:</p>

<p><em>Código:</em></p>

<pre><code>puts 'Hola, ¿cual es tu nombre?'
  name = gets.chomp
  puts 'Hola, ' + name + '.'
  if name == 'Chris'
  puts '¡Que nombre tan hermoso!'
  end
</code></pre>

<p><em>si respondemos 'Chris':</em></p>

<pre><code>Hola, ¿cual es tu nombre?
  Chris
  Hola, Chris.
  ¡Que nombre tan hermoso!
</code></pre>

<p><em>pero si ponemos otro nombre:</em></p>

<pre><code>Hola, ¿cual es tu nombre?
  Chewbacca
  Hola, Chewbacca.
</code></pre>

<p>Y eso es una ramificación. Si lo que viene luego del <code>if</code> es <code>true</code> (es decir, si es
  cierto), se ejecutará el código entre el <code>if</code> y el <code>end</code>. Y no se ejecutará si lo que
  viene luego del <code>if</code> es <code>false</code> (falso). Más facil imposible.</p>

<p>He indentado el código entre <code>if</code> y el <code>end</code> solo porque me parece que es más
  facil leer las ramificaciones de esa manera. Casi todos los programadores lo hacen
  así, sin importar el lenguaje en que estén programando. No parece ser de mucha ayuda
  en este ejemplo, pero cuando las cosas se vuelven complejas, es una gran diferencia.</p>

<p>Varias veces nos gustaría que un programa haga alguna cosa si una expresión
  es <code>true</code>, y otra cosa si es que es <code>false</code>. Para eso es que existe <code>else</code>:</p>

<p><em>Código:</em></p>

<pre><code>puts 'Soy un adivino. Dime tu nombre:'
  name = gets.chomp
  if name == 'Chris'
  puts 'Veo grandes cosas en tu futuro.'
  else
  puts 'Tu futuro es... ¡Oh! ¡Mira la hora!'
  puts 'Realmente debo irme, ¡lo siento!'
  end
</code></pre>

<p><em>si respondemos 'Chris':</em></p>

<pre><code>Soy un adivino. Dime tu nombre:
  Chris
  Veo grandes cosas en tu futuro.
</code></pre>

<p><em>Si tratamos con un nombre diferente:</em></p>

<pre><code>Soy un adivino. Dime tu nombre:
  Ringo
  Tu futuro es... ¡Oh! ¡Mira la hora!
  Realmente debo irme, ¡lo siento!
</code></pre>

<p>Las ramificaciones son como encontrar una bifurcación en el código:
  ¿Seguimos el camino de las personas cuyo <code>name == 'Chris'</code> o el camino de
  aquellas que no (<code>else</code>)?</p>

<p>Y como las ramas de un árbol, puedes tener ramificaciones que a su vez tengan
  otras ramificaciones:</p>

<p><em>Código:</em></p>

<pre><code>puts 'Hola, y bienvenido a la clase de 7mo año.'
  puts 'Me llamo Mrs. Gabbard. ¿Tú nombre es...?'
  nombre = gets.chomp

  if nombre == nombre.capitalize
  puts 'Por favor, toma asiento ' + nombre + '.'
  else
  puts '¿' + nombre + '? Quieres decir ' + nombre.capitalize + ', ¿cierto?'
  puts '¿No sabes escribir tu propio nombre?'
  respuesta = gets.chomp

  if respuesta.downcase == 'si'
  puts '¡Hum! Bueno, ¡siéntese!'
  else
  puts '¡SALGA DEL SALON!'
  end
  end
</code></pre>

<p><em>si respondemos el nombre en minúsculas:</em></p>

<pre><code>Hola, y bienvenido a la clase de 7mo año.
  Me llamo Mrs. Gabbard. ¿Tú nombre es...?
  chris
  ¿chris? Quieres decir Chris, ¿cierto?
  ¿No sabes escribir tu propio nombre?
  si
  ¡Hum! Bueno, ¡siéntese!
</code></pre>

<p><em>y si respondemos el nombre como debe ser:</em></p>

<pre><code>Hola, y bienvenido a la clase de 7mo año.
  Me llamo Mrs. Gabbard. ¿Tú nombre es...?
  Chris
  Por favor, toma asiento Chris.
</code></pre>

<p>Algunas veces puede ser algo confuso entender donde todos los <code>if</code>s, <code>else</code>s, y
  <code>end</code>s van. Lo que yo hago es escribir el <code>end</code> <em>al mismo tiempo</em> que escribo el
  <code>if</code>. Así es que como se veía al principio el programa de arriba según lo iba
  escribiendo:</p>

<pre><code>puts 'Hola, y bienvenido a la clase de 7mo año.'
  puts 'Me llamo Mrs. Gabbard. ¿Tú nombre es...?'
  nombre = gets.chomp

  if nombre == nombre.capitalize
  else
  end
</code></pre>

<p>Entonces lo llené con <em>comentarios</em>, cosas en el código que la computadora ignorará:</p>

<pre><code>puts 'Hola, y bienvenido a la clase de 7mo año.'
  puts 'Me llamo Mrs. Gabbard. ¿Tú nombre es...?'
  nombre = gets.chomp

  if nombre == nombre.capitalize
  # Me trata como una persona normal.
  else
  # Se vuelve loca.
  end
</code></pre>

<p>Todo lo que aparezca luego de un <code>#</code> se considera un comentario (a menos, claro,
  que estés en un texto). Después de eso, reemplacé los comentarios con
  código funcional. Algunas personas prefieren dejar los comentarios; personalmente,
  pienso que un código bien escrito normalmente habla por si mismo. Solía utilizar más
  comentarios, pero mientras más "flúido" me volvía con Ruby menos los utiliza.
  Actualmente los encuentro algo distrayentes la mayor parte del tiempo. Es una opción
  personal; tú encontrarás tu propio estilo (siempre en evolución). Así que mi siguiente
  paso se veía así:</p>

<pre><code>puts 'Hola, y bienvenido a la clase de 7mo año.'
  puts 'Me llamo Mrs. Gabbard. ¿Tú nombre es...?'
  nombre = gets.chomp

  if nombre == nombre.capitalize
  puts 'Por favor, toma asiento ' + nombre + '.'
  else
  puts '¿' + nombre + '? Quieres decir ' + nombre.capitalize + ', ¿cierto?'
  puts '¿No sabes escribir tu propio nombre?'
  respuesta = gets.chomp

  if respuesta.downcase == 'si'
  else
  end
  end
</code></pre>

<p>De nuevo, escribí los <code>if</code>, <code>else</code>, y <code>end</code> juntos. Realmente me ayuda para saber
  "donde estoy" en el código. Tambien permite que el trabajo parezca más sencillo ya que
  me permite enfocarme en una pequeña parte, como en llenar el código entre <code>if</code> y el
  <code>else</code>. El otro beneficio de realizarlo de esta manera es que el computador puede entender
  el programa en cualquier etapa. Cualquiera de las versiones incompletas del programa
  que te mostré se podrían ejecutar. No estaban finalizadas, pero eran programas funcionales.
  De esa manera, podría probarlo mientras lo escribo, lo que ayuda a ver como voy avanzando
  y donde aún necesito trabajar. Cuando pase todas las pruebas sé que he terminado.</p>

<p>Estos tipos te ayudarán a escribir programas con ramificaciones pero también te ayudarán
  con otros tipos de control de flujo:</p>

<h2>
  <a name="bucles" class="anchor" href="#bucles"><span class="mini-icon mini-icon-link"></span></a>Bucles</h2>

<p>A veces querrás que tu computadora haga la misma acción una y otra vez —después
  de todo se supone que en eso son buenas las computadoras—.</p>

<p>Cuando le dices a la computadora que siga repitiendo algo, también debes decirle cuando
  parar. Las computadoras nunca se aburren asi que si no le indicas cuando hacerlo nunca
  lo harán. Nos aseguramos que esto no pase al indicarle a la computadora que repita
  ciertas partes de un programe mientras (<code>while</code>) una cierta condición sea cierta.
  Ésto funciona de manera muy similar a como lo hace <code>if</code>:</p>

<p><em>Código:</em></p>

<pre><code>comando = ''

  while comando != 'adios'
  puts comando
  comando = gets.chomp
  end

  puts '¡Vuelve pronto!'
</code></pre>

<p><em>Respuesta:</em></p>

<pre><code>¿Hola?
  ¿Hola?
  ¡Hola!
  ¡Hola!
  Un gusto conocerlo
  Un gusto conocerlo
  ¡Oh... que amable!
  ¡Oh... que amable!
  adios
  ¡Vuelve pronto!
</code></pre>

<p>Y eso es un bucle. (Tal vez te has dado cuenta de la línea vacía que sale al inicio del resultado;
  viene de ejecutar el primer <code>puts</code>, antes del primer <code>gets</code>. ¿Cómo cambiarías el programa
  para eliminar esa primera línea? ¡Pruébalo! ¿Funcionó +exactamente+ igual que el programa
  de arriba, sin contar la primera línea blanca?)</p>

<p>Los bucles nos permiten hacer una serie de cosas interesantes, como estoy seguro te
  podrás imaginar. Sin embargo, también pueden causar problemas si cometes un error.
  ¿Qué pasaría si tu computadora se queda atrapado en un bucle infinito? Si piensas
  que eso te ha ocurrido, solo presiona la tecla +Ctrl+ y luego la +C+.</p>

<p>Antes de empezar a jugar con los bucles, aprendamos un par de cosas que nos
  permitirán hacer nuestro trabajo más facil.</p>

<h2>
  <a name="un-poco-de-l%C3%B3gica" class="anchor" href="#un-poco-de-l%C3%B3gica"><span class="mini-icon mini-icon-link"></span></a>Un
  poco de lógica</h2>

<p>Echémosle un vistazo a nuestro primer programa de condicionales una vez más.
  ¿Qué pasaría si mi esposa llega a casa, ve el programa, lo prueba y éste no
  le dice que <em>ella</em> tiene un nombre hermoso. Yo no querría herir sus sentimientos
  (o dormir en el sillón) así que reescribámoslo:</p>

<p><em>Código:</em></p>

<pre><code>puts 'Hola, ¿cual es tu nombre?'
  nombre = gets.chomp
  puts 'Hola, ' + nombre + '.'
  if nombre == 'Chris'
  puts '¡Que nombre tan hermoso!'
  else
  if nombre == 'Katy'
  puts '¡Que nombre tan hermoso!'
  end
  end
</code></pre>

<p><em>Respuesta:</em></p>

<pre><code>Hola, ¿cual es tu nombre?
  Katy
  Hola, Katy.
  ¡Que nombre tan hermoso!
</code></pre>

<p>Bueno, funciona... pero no es un programa muy bonito. ¿Por qué no? Bueno, la mejor
  regla que he aprendido de programación es la regla <em>DRY</em>: Don't Repeat Yourself_ ("No
  te repitas" en español). Probablemente podría escribir un libro pequeño sobre por qué es tan buena
  esta regla. En nuestro caso, hemos repetido la línea <code>puts 'Que nombre tan hermoso!'</code>. ¿Por qué
  es tan problemático esto? Bueno, que pasaría si cometiera un error al escribir los textos cuando
  reescribí el programa? ¿Que tal si hubiera querido cambiar de <code>'hermoso'</code> a <code>'bonito'</code> en ambas
  líneas?</p>

<p>Soy flojo, ¿recuerdas? Básicamente si quisiera que el programa haga lo mismo cuando reciba <code>'Chris'</code>
  o <code>'Katy'</code>, entonces realmente debería hacer exactamente <em>la misma cosa</em>:</p>

<p><em>Código:</em></p>

<pre><code>puts 'Hola, ¿cual es tu nombre?'
  nombre = gets.chomp
  puts 'Hola, ' + nombre + '.'
  if (nombre == 'Chris' or nombre == 'Katy')
  puts '¡Que nombre tan hermoso!'
  end
</code></pre>

<p><em>Respuesta:</em></p>

<pre><code>Hola, ¿cual es tu nombre?
  Katy
  Hola, Katy.
  ¡Que nombre tan hermoso!
</code></pre>

<p>Mucho mejor. Para hacer que funcione, he utilizado el operador <code>or</code>. Los otros <em>operadores
  lógicos</em> son <code>and</code> y <code>not</code>. Siempre es una buena idea usar los paréntesis cuando trabajamos
  con éstos. Veamos como funcionan:</p>

<p><em>Código:</em></p>

<pre><code>soyChris = true
  soyMorado = false
  meGustaLaComida = true
  comoRocas = false

  puts (soyChris and meGustaLaComida)
  puts (meGustaLaComida and comoRocas)
  puts (soyMorado and meGustaLaComida)
  puts (soyMorado and comoRocas)
  puts
  puts (soyChris or meGustaLaComida)
  puts (meGustaLaComida or comoRocas)
  puts (soyMorado or meGustaLaComida)
  puts (soyMorado or comoRocas)
  puts
  puts (not soyMorado)
  puts (not soyChris)
</code></pre>

<p><em>Respuesta:</em></p>

<pre><code>true
  false
  false
  false

  true
  true
  true
  false

  true
  false
</code></pre>

<p>La única de esas sentencias que te podría confundir es el <code>or</code>. En español normalmente decimos
  "uno u otro, pero no los dos". Por ejemplo, tu mamá podría decir "Para postre puedes pedir pie o
  torta". ¡Ella <em>no</em> quiso decir que podrías tener ambos!</p>

<p>Una computadora, por otro lado, usa <code>or</code> (o) para decir "uno u otro o los dos" (Otra manera de
  decirlo es "al menos una de estas debe ser cierta"). Es por eso que las computadoras son más divertidas
  que mamá.</p>

<h2>
  <a name="algunas-cosas-por-intentar" class="anchor" href="#algunas-cosas-por-intentar"><span class="mini-icon mini-icon-link"></span></a>Algunas
  cosas por intentar</h2>

<p>•<em>"99 botellas de cerveza en la pared..."</em> Escribe un programa que imprima la letra del clásico
  en viajes
  <a href="http://en.wikipedia.org/wiki/99_Bottles_of_Beer" target="_blank">99 botellas de cerveza en la pared"</a></p>

<p>•Escribe un programa de la Abuela Sorda. Lo que sea que le digas a la abuela (lo que sea que escribas),
  ella deberá responder con HUH?! ¡HABLA MAS FUERTE, HIJO!<code>, a menos que le grites (escribas todo
  en mayúsculas) Si le gritas, ella te escuchará (o al menos creerá eso) y te gritará de vuelta NO, ¡NO
  DESDE 1938!</code>. Para hacer el programa <em>realmente</em> creíble, haz que la abuela grite un año
  distinto cada vez; tal vez un año aleatorio entre 1930 y 1950. (Esta parte es opcional y sería mucho
  más facil si lees la sección sobre generadores de números aleatorios de Ruby al final del capítulo
  <%= link_to "métodos", :controller => :ruby, :action => :metodos %>) No podrás dejar de
  hablar con la abuela hasta que le grites <code>ADIOS</code>.<br><em><strong>Pista:</strong> ¡No te olvides que
</em><code>chomp</code><em>! ¡</em><code>'ADIOS'</code><em>con un Enter
  no es lo mismo que </em><code>'ADIOS'</code><em> sin uno!</em><br>. <em><strong>Pista 2:</strong> Trata de pensar
  que partes del programa deberían suceder una y otra vez. Todas ellas deberían estar en tu bucle</em><code>while</code>.
</p>

<p>• Extiende el programa de la Abuela Sorda. ¿Qué pasaría si la abuela no quiere que te vayas?
  Cuando le grites <code>ADIOS</code>, ella podría pretender que no te escucha. Cambia el programa previo para
  que tengas que gritar <code>ADIOS</code> tres veces <em>seguidas</em>. Asegúrate que tu programa: si gritas ADIOS`
  tres veces, pero no seguidas, deberías seguir hablando con la abuela.</p>

<p>• Años bisiestos. Escribe un programa que pregunte por un año de inicio y uno de fin, y luego
  imprima (<code>puts</code>) todos los años bisiestos que han ocurrido entre ellos (incluyéndolos si también han
  sido estos años bisiestos). Los años bisiestos son divisibles entre cuatro (como 1984 y 2004). Sin
  embargo, los años divisibles entre 100 <em>no</em> son años bisiestos (como 1800 y 1900) <strong><em>a
  menos</em></strong> que sean divisibles por 400 (como 1600 y 2000, los cuales fueron, de hecho, bisiestos).
  <em>(Sí, todo es bastante confuso, pero no tanto como tener Enero en medio del invierno, lo cual es
    algo que a veces sucede)</em></p>

<p>Cuando termines con ellos, ¡tómate un descanso! Haz aprendido un montón hasta ahora. ¡Felicitaciones! ¿Estás
  sorprendido de la cantidad de cosas que le puedes pedir hacer a una computadora? Unos capítulos más y
  serás capaz de programar cualquier cosas. ¡En serio! Solo mira la cantidad de cosas que puedes hacer ahora
  que antes cuando no tenías bucles y ramificaciones.</p>

<p>Ahora, aprendamos sobre un nuevo tipo de objeto, que permite tener control de listas de otros objetos:
  <%= link_to "matrices", :controller => :ruby, :action => :matrices %>.</p></article>
</div>